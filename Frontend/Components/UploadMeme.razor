@using System.Data.Common
@using BlazorApi.Services
@using Frontend.Services
@inject ApiService Api
@inject StorageService Storage
@inject IJSRuntime JS

<div class="first-layer-card first-layer-card-padding-margins upload-card js-upload-height">
    <label for="uploadMemeInput" class="btn btn-warning mb-2">
        Choose meme
    </label>
    <InputText @bind-Value="@_uploadMemeName" class="form-control" style="width: unset" placeholder="Name..."/>
    <InputFile OnChange="OnInputFileChange" accept="image/*,video/*" id="uploadMemeInput" style="display:none"/>

    <button class="btn btn-warning my-2" @onclick="AddTagToTagsAsync">Add tag</button>
    <InputText @bind-Value="_currentTag" class="form-control" style="width: unset" placeholder="Tag..."/>

    <button class="btn btn-warning my-2" @onclick="UploadMemeAsync">Upload Meme</button>

    @if (!string.IsNullOrEmpty(_filePreviewUrl) && !string.IsNullOrEmpty(_fileType))
    {
        if (_fileType.StartsWith("image"))
        {
            <img src="@_filePreviewUrl" style="width: 100px" alt="Preview image..."/>
        }
        else if (_fileType.StartsWith("video"))
        {
            <video src="@_filePreviewUrl" style="width: 150px" controls></video>
        }
    }

    <div>
        @foreach (string tag in _tags)
        {
            <p>@tag</p>
        }
    </div>
</div>

<style>
    .upload-card {
        height: 251px;
        transition: all 0.3s;
        overflow: hidden;
    }
</style>

@code {

    private string _uploadMemeName = string.Empty;
    private string _currentTag = string.Empty;
    private IBrowserFile? _memeImage;
    private List<string> _tags = [];
    private string? _filePreviewUrl;
    private string? _fileType;

    private async Task AddTagToTagsAsync()
    {
        _tags.Add(_currentTag);
        _currentTag = string.Empty;
        await JS.InvokeVoidAsync("maxHeight.add40Height", "js-upload-height");
    }

    private void EmptyTags() => _tags = [];

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        _memeImage = e.File;
        _fileType = _memeImage.ContentType;

        var buffer = new byte[_memeImage.Size];
        await _memeImage.OpenReadStream(_memeImage.Size).ReadAsync(buffer);
        _filePreviewUrl = $"data:{_memeImage.ContentType};base64,{Convert.ToBase64String(buffer)}";
        StateHasChanged();
    }

    private async Task UploadMemeAsync()
    {
        if (_uploadMemeName == "")
        {
            await JS.InvokeVoidAsync("alert", "No name given for meme");
            return;
        }

        if (_memeImage == null)
        {
            await JS.InvokeVoidAsync("alert", "No image uploaded");
            return;
        }

        try
        {
            string? token = await Storage.GetItemFromLocalStorageAsync("authToken");

            if (string.IsNullOrEmpty(token))
            {
                await JS.InvokeVoidAsync("alert", "No auth token found");
                return;
            }

            var result = await Api.UploadMemeAsync(_memeImage, _tags, _uploadMemeName, token);
            EmptyTags();
            _filePreviewUrl = null;
            _memeImage = null;
            await JS.InvokeVoidAsync("alert", result);
            await JS.InvokeVoidAsync("maxHeight.resetHeight", "js-upload-height");
            StateHasChanged();
        }
        catch (DbException ex)
        {
            await JS.InvokeVoidAsync("alert", "DB Exception caught uploading meme: " + ex.Message);
            return;
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", "Generel Exception caught uploading meme: " + ex.Message);
            return;
        }
    }

}